A. 【构造，分讨】 给你一棵树，n<100，你可以选择一条链1,2,3,4 断开1-2 , 2-3, 3-4连接 1-3，1-4，2-4，输出构造方案使得树的直径是4（三条边）

希望jyh能做这个题，自己纸上画图思考20分钟，把大概想法和观察到的性质写出来，之后可以看题解； 想清楚了实现一下代码 2kb左右的代码

E. 【数据结构】给一棵有根树,有边权，路径加（加正数），输出最小化的轻边权值和

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =110;
vector<int>e[N];
int fa[N],dep[N];
struct ANS
{
    int a,b,c,d;
};
vector<ANS>ans;

void dfs(int u,int pa){
    dep[u]=dep[pa]+1;
    fa[u]=pa;
    for(auto v:e[u])if(v!=pa){
        dfs(v,u);
    }
}
void ER(int a,int b){
    e[a].erase(find(e[a].begin(),e[a].end(),b));
    e[b].erase(find(e[b].begin(),e[b].end(),a));
}
void add(int a,int b){
    e[a].push_back(b);
    e[b].push_back(a);
}
void opt(int a,int b,int c,int d){
    ans.push_back({a,b,c,d});
    ER(a,b);ER(b,c);ER(c,d);
    add(a,c);add(a,d);add(b,d);
    // cerr<<a<<" "<<b<<" "<<c<<" "<<d<<endl;
}
int n;
int vis[N];
int findnt(int u,int v){
    return e[u][0]==v?e[u][1]:e[u][0];
}
signed main(){
    int st=0;
    cin>>n;
    for(int i=1;i<n;++i){
        int u,v;
        cin>>u>>v;add(u,v);
    }
    int u=0;
    for(int i=1;i<=n;++i){
        if(e[i].size()==1){u=i;break;}
    }
    int solve=1;
    vis[u]=1;
    u=e[u][0];
    while(e[u].size()+solve!=n){
        vis[u]=1;
        if(e[u].size()==2){
            solve++;
            u=vis[e[u][0]]?e[u][1]:e[u][0];
            continue;
        }
        else{
            int f1=0,f2=0;
            for(int v:e[u]){
                if(vis[v])continue;
                if(e[v].size()>=2){
                    if(f1==0)f1=v;
                    else f2=v;
                }
                else f2=v;
            }
            int f3=e[f1][0]==u?e[f1][1]:e[f1][0];
            opt(f2,u,f1,f3);
        }
    }
    while(solve>=3){
        solve=solve-3;
        int f2;
        for(int v:e[u])if(vis[v])f2=v;
        int f3=findnt(f2,u),f4=findnt(f3,f2);
        opt(u,f2,f3,f4);
        if(solve<=1)break;
        int f5;
        for(int v:e[f4])if(v!=f2&&v!=u)f5=v;
        int f6=findnt(f5,f4);
        opt(u,f4,f5,f6);
        opt(u,f6,f4,f2);
    }
    int cnt=0;
    // for(int i=1;i<=n;++i)cnt+=(e[i].size()>=2),cout<<e[i].size()<<" ";
    // if(cnt<=2)cout<<"YES";
    cout<<ans.size()<<endl;
    for(auto it:ans){
        cout<<it.a<<" "<<it.b<<" "<<it.c<<" "<<it.d<<endl;
    }
  
}
```


（树的形态固定，但是遇到重儿子多个的时候可以自由选择重边）

xjy要把这道题补了，码长不超过4k (自己想办法)


~~H. 性质观察题，正解是分块加性质，有兴趣可以了解，不要求~~


J.【签到】 n个变色龙在二维平面上， 有坐标和颜色，现在需要让第一个变色龙叫醒第n个：1. 一个变色龙1s可以走到八邻域内()形如(x-1,y+1)这个点）；2. 不同颜色的变色龙若在同一个x轴或者y轴，可以直接叫醒另一个（不需要时间）；3. a走到b的位置，也可以叫醒b；4. a叫醒了b，a就会在原地睡着，也就是场上只有一个变色龙醒着，能移动

求最短时间 n=1e5

前中期题，简单最短路模型，想明白怎么建图就行了，三个人都要补，代码2k，20min

K 【博弈论，比较模型的题】: 

给一个数列a[n]，两人轮流操作，可以选一个数字a[i]，获得a[i]%2的分数，并使得a[i]/2;问先手比后手能多几分

三个人都想想吧，然后学一下这个模型，记一下结论就行了

之后jyh补一下这道题，代码不超过1k


L【完全背包性质】： 给定rc<1e12,有n个物品，有价格a[i]和购买的票数b[i];

a[i]<300; 每个物品可以无限购买; 最小化 A+rc/B  (小数除法)

大家都思考一下这道题，学一下这个性质
